// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: message.sql

package database

import (
	"context"
	"database/sql"
	"time"

	"github.com/google/uuid"
)

const checkRoomExist = `-- name: CheckRoomExist :one
SELECT id, user1_id, user2_id, created_at
FROM rooms
WHERE (user1_id = LEAST($1::uuid, $2::uuid)
       AND user2_id = GREATEST($1::uuid, $2::uuid))
LIMIT 1
`

type CheckRoomExistParams struct {
	Column1 uuid.UUID
	Column2 uuid.UUID
}

func (q *Queries) CheckRoomExist(ctx context.Context, arg CheckRoomExistParams) (Room, error) {
	row := q.db.QueryRowContext(ctx, checkRoomExist, arg.Column1, arg.Column2)
	var i Room
	err := row.Scan(
		&i.ID,
		&i.User1ID,
		&i.User2ID,
		&i.CreatedAt,
	)
	return i, err
}

const checkUserInRoom = `-- name: CheckUserInRoom :one

SELECT EXISTS(
    SELECT 1
    FROM rooms
    WHERE id = $1 AND (user1_id = $2 OR user2_id = $2)
)
`

type CheckUserInRoomParams struct {
	ID      uuid.UUID
	User1ID uuid.UUID
}

// SẮP XẾP THEO THỜI GIAN CỦA TIN NHẮN CUỐI CÙNG
func (q *Queries) CheckUserInRoom(ctx context.Context, arg CheckUserInRoomParams) (bool, error) {
	row := q.db.QueryRowContext(ctx, checkUserInRoom, arg.ID, arg.User1ID)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const createRoom = `-- name: CreateRoom :one
INSERT INTO rooms (user1_id, user2_id)
VALUES (LEAST($1::uuid, $2::uuid), GREATEST($1::uuid, $2::uuid))
RETURNING id, user1_id, user2_id, created_at
`

type CreateRoomParams struct {
	Column1 uuid.UUID
	Column2 uuid.UUID
}

func (q *Queries) CreateRoom(ctx context.Context, arg CreateRoomParams) (Room, error) {
	row := q.db.QueryRowContext(ctx, createRoom, arg.Column1, arg.Column2)
	var i Room
	err := row.Scan(
		&i.ID,
		&i.User1ID,
		&i.User2ID,
		&i.CreatedAt,
	)
	return i, err
}

const getChatHistory = `-- name: GetChatHistory :many
SELECT id, room_id, sender_id, receiver_id, content, sent_at FROM messages
WHERE room_id = $1 AND sent_at < $2
ORDER BY sent_at DESC
LIMIT 10
`

type GetChatHistoryParams struct {
	RoomID uuid.UUID
	SentAt time.Time
}

func (q *Queries) GetChatHistory(ctx context.Context, arg GetChatHistoryParams) ([]Message, error) {
	rows, err := q.db.QueryContext(ctx, getChatHistory, arg.RoomID, arg.SentAt)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Message
	for rows.Next() {
		var i Message
		if err := rows.Scan(
			&i.ID,
			&i.RoomID,
			&i.SenderID,
			&i.ReceiverID,
			&i.Content,
			&i.SentAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRoomChatByUserId = `-- name: GetRoomChatByUserId :many
SELECT
    r.id,
    r.user1_id,
    u1.names AS user1_name,
    u1.profile_pic AS user1_profile_pic,
    r.user2_id,
    u2.names AS user2_name,
    u2.profile_pic AS user2_profile_pic,
    r.created_at,
    (SELECT content FROM messages WHERE room_id = r.id ORDER BY sent_at DESC LIMIT 1) AS last_message,
    (SELECT sent_at FROM messages WHERE room_id = r.id ORDER BY sent_at DESC LIMIT 1) AS last_message_time
FROM
    rooms r
JOIN users u1 ON r.user1_id = u1.id
JOIN users u2 ON r.user2_id = u2.id
WHERE
    r.user1_id = $1 OR r.user2_id = $1
ORDER BY
    last_message_time DESC
`

type GetRoomChatByUserIdRow struct {
	ID              uuid.UUID
	User1ID         uuid.UUID
	User1Name       string
	User1ProfilePic sql.NullString
	User2ID         uuid.UUID
	User2Name       string
	User2ProfilePic sql.NullString
	CreatedAt       time.Time
	LastMessage     string
	LastMessageTime time.Time
}

func (q *Queries) GetRoomChatByUserId(ctx context.Context, user1ID uuid.UUID) ([]GetRoomChatByUserIdRow, error) {
	rows, err := q.db.QueryContext(ctx, getRoomChatByUserId, user1ID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetRoomChatByUserIdRow
	for rows.Next() {
		var i GetRoomChatByUserIdRow
		if err := rows.Scan(
			&i.ID,
			&i.User1ID,
			&i.User1Name,
			&i.User1ProfilePic,
			&i.User2ID,
			&i.User2Name,
			&i.User2ProfilePic,
			&i.CreatedAt,
			&i.LastMessage,
			&i.LastMessageTime,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRoomInfo = `-- name: GetRoomInfo :one
SELECT 
    r.id AS room_id,
    u1.id AS user1_id,
    u1.names AS user1_name,
    u1.profile_pic AS user1_profile_pic,
    u2.id AS user2_id,
    u2.names AS user2_name,
    u2.profile_pic AS user2_profile_pic
FROM rooms r
JOIN users u1 ON r.user1_id = u1.id
JOIN users u2 ON r.user2_id = u2.id
WHERE r.id = $1
`

type GetRoomInfoRow struct {
	RoomID          uuid.UUID
	User1ID         uuid.UUID
	User1Name       string
	User1ProfilePic sql.NullString
	User2ID         uuid.UUID
	User2Name       string
	User2ProfilePic sql.NullString
}

func (q *Queries) GetRoomInfo(ctx context.Context, id uuid.UUID) (GetRoomInfoRow, error) {
	row := q.db.QueryRowContext(ctx, getRoomInfo, id)
	var i GetRoomInfoRow
	err := row.Scan(
		&i.RoomID,
		&i.User1ID,
		&i.User1Name,
		&i.User1ProfilePic,
		&i.User2ID,
		&i.User2Name,
		&i.User2ProfilePic,
	)
	return i, err
}

const setChatHistory = `-- name: SetChatHistory :one
INSERT INTO messages (room_id, sender_id, receiver_id, content)
VALUES ($1, $2, $3, $4)
RETURNING id, room_id, sender_id, receiver_id, content, sent_at
`

type SetChatHistoryParams struct {
	RoomID     uuid.UUID
	SenderID   uuid.UUID
	ReceiverID uuid.UUID
	Content    string
}

func (q *Queries) SetChatHistory(ctx context.Context, arg SetChatHistoryParams) (Message, error) {
	row := q.db.QueryRowContext(ctx, setChatHistory,
		arg.RoomID,
		arg.SenderID,
		arg.ReceiverID,
		arg.Content,
	)
	var i Message
	err := row.Scan(
		&i.ID,
		&i.RoomID,
		&i.SenderID,
		&i.ReceiverID,
		&i.Content,
		&i.SentAt,
	)
	return i, err
}
