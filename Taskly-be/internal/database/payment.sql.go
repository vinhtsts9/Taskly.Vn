// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: payment.sql

package database

import (
	"context"
	"database/sql"
	"encoding/json"
	"time"

	"github.com/google/uuid"
	"github.com/sqlc-dev/pqtype"
)

const createLedgerEntry = `-- name: CreateLedgerEntry :one

INSERT INTO ledger_entry (wallet_id, transaction_id, amount_bigint, balance_after, entry_type)
VALUES ($1, $2, $3, $4, $5)
RETURNING id, wallet_id, transaction_id, amount_bigint, balance_after, entry_type, created_at
`

type CreateLedgerEntryParams struct {
	WalletID      uuid.NullUUID
	TransactionID uuid.NullUUID
	AmountBigint  int64
	BalanceAfter  int64
	EntryType     string
}

type CreateLedgerEntryRow struct {
	ID            uuid.UUID
	WalletID      uuid.NullUUID
	TransactionID uuid.NullUUID
	AmountBigint  int64
	BalanceAfter  int64
	EntryType     string
	CreatedAt     time.Time
}

// =========================
// Ledger entries
// =========================
func (q *Queries) CreateLedgerEntry(ctx context.Context, arg CreateLedgerEntryParams) (CreateLedgerEntryRow, error) {
	row := q.db.QueryRowContext(ctx, createLedgerEntry,
		arg.WalletID,
		arg.TransactionID,
		arg.AmountBigint,
		arg.BalanceAfter,
		arg.EntryType,
	)
	var i CreateLedgerEntryRow
	err := row.Scan(
		&i.ID,
		&i.WalletID,
		&i.TransactionID,
		&i.AmountBigint,
		&i.BalanceAfter,
		&i.EntryType,
		&i.CreatedAt,
	)
	return i, err
}

const createPaymentTransaction = `-- name: CreatePaymentTransaction :one

INSERT INTO payment_transaction (
  topup_order_id,
  provider,
  provider_tx_id,
  amount_bigint,
  status,
  remote_payload,
  signature,
  verified_at
)
VALUES ($1, $2, $3, $4, $5, $6::jsonb, $7, $8)
RETURNING id, topup_order_id, provider, provider_tx_id, amount_bigint, status, remote_payload, signature, verified_at, created_at
`

type CreatePaymentTransactionParams struct {
	TopupOrderID uuid.NullUUID
	Provider     string
	ProviderTxID string
	AmountBigint int64
	Status       string
	Column6      json.RawMessage
	Signature    sql.NullString
	VerifiedAt   sql.NullTime
}

type CreatePaymentTransactionRow struct {
	ID            uuid.UUID
	TopupOrderID  uuid.NullUUID
	Provider      string
	ProviderTxID  string
	AmountBigint  int64
	Status        string
	RemotePayload pqtype.NullRawMessage
	Signature     sql.NullString
	VerifiedAt    sql.NullTime
	CreatedAt     time.Time
}

// =========================
// Payment Transaction (provider callbacks)
// =========================
func (q *Queries) CreatePaymentTransaction(ctx context.Context, arg CreatePaymentTransactionParams) (CreatePaymentTransactionRow, error) {
	row := q.db.QueryRowContext(ctx, createPaymentTransaction,
		arg.TopupOrderID,
		arg.Provider,
		arg.ProviderTxID,
		arg.AmountBigint,
		arg.Status,
		arg.Column6,
		arg.Signature,
		arg.VerifiedAt,
	)
	var i CreatePaymentTransactionRow
	err := row.Scan(
		&i.ID,
		&i.TopupOrderID,
		&i.Provider,
		&i.ProviderTxID,
		&i.AmountBigint,
		&i.Status,
		&i.RemotePayload,
		&i.Signature,
		&i.VerifiedAt,
		&i.CreatedAt,
	)
	return i, err
}

const createTopupOrder = `-- name: CreateTopupOrder :one

INSERT INTO topup_order (
  user_id,
  order_id,
  reference_code,
  idempotency_key,
  amount_bigint,
  currency,
  provider,
  provider_payment_url,
  status,
  expires_at
)
VALUES (
  $1, $2, $3, $4, $5, $6, $7, $8, $9, $10
)
ON CONFLICT (idempotency_key) DO UPDATE
  SET updated_at = NOW()
RETURNING id, user_id, order_id, reference_code, idempotency_key, amount_bigint, currency, provider, provider_payment_url, status, created_at, updated_at, expires_at
`

type CreateTopupOrderParams struct {
	UserID             uuid.UUID
	OrderID            uuid.NullUUID
	ReferenceCode      string
	IdempotencyKey     string
	AmountBigint       int64
	Currency           string
	Provider           string
	ProviderPaymentUrl sql.NullString
	Status             string
	ExpiresAt          sql.NullTime
}

// =========================
// Topup / Payment intent
// =========================
func (q *Queries) CreateTopupOrder(ctx context.Context, arg CreateTopupOrderParams) (TopupOrder, error) {
	row := q.db.QueryRowContext(ctx, createTopupOrder,
		arg.UserID,
		arg.OrderID,
		arg.ReferenceCode,
		arg.IdempotencyKey,
		arg.AmountBigint,
		arg.Currency,
		arg.Provider,
		arg.ProviderPaymentUrl,
		arg.Status,
		arg.ExpiresAt,
	)
	var i TopupOrder
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.OrderID,
		&i.ReferenceCode,
		&i.IdempotencyKey,
		&i.AmountBigint,
		&i.Currency,
		&i.Provider,
		&i.ProviderPaymentUrl,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ExpiresAt,
	)
	return i, err
}

const createWallet = `-- name: CreateWallet :one
INSERT INTO wallet (user_id, balance_bigint)
VALUES ($1, $2)
RETURNING id, user_id, balance_bigint, updated_at, created_at
`

type CreateWalletParams struct {
	UserID        uuid.UUID
	BalanceBigint int64
}

type CreateWalletRow struct {
	ID            uuid.UUID
	UserID        uuid.UUID
	BalanceBigint int64
	UpdatedAt     time.Time
	CreatedAt     time.Time
}

func (q *Queries) CreateWallet(ctx context.Context, arg CreateWalletParams) (CreateWalletRow, error) {
	row := q.db.QueryRowContext(ctx, createWallet, arg.UserID, arg.BalanceBigint)
	var i CreateWalletRow
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.BalanceBigint,
		&i.UpdatedAt,
		&i.CreatedAt,
	)
	return i, err
}

const getLastPendingTopupByOrder = `-- name: GetLastPendingTopupByOrder :one
SELECT id, user_id, order_id, reference_code, idempotency_key, amount_bigint, currency, provider, provider_payment_url, status, created_at, updated_at, expires_at
FROM topup_order
WHERE order_id = $1 AND status = 'PENDING'
ORDER BY created_at DESC
LIMIT 1
`

func (q *Queries) GetLastPendingTopupByOrder(ctx context.Context, orderID uuid.NullUUID) (TopupOrder, error) {
	row := q.db.QueryRowContext(ctx, getLastPendingTopupByOrder, orderID)
	var i TopupOrder
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.OrderID,
		&i.ReferenceCode,
		&i.IdempotencyKey,
		&i.AmountBigint,
		&i.Currency,
		&i.Provider,
		&i.ProviderPaymentUrl,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ExpiresAt,
	)
	return i, err
}

const getLedgerEntriesByWallet = `-- name: GetLedgerEntriesByWallet :many
SELECT id, wallet_id, transaction_id, amount_bigint, balance_after, entry_type, created_at
FROM ledger_entry
WHERE wallet_id = $1
ORDER BY created_at DESC
`

type GetLedgerEntriesByWalletRow struct {
	ID            uuid.UUID
	WalletID      uuid.NullUUID
	TransactionID uuid.NullUUID
	AmountBigint  int64
	BalanceAfter  int64
	EntryType     string
	CreatedAt     time.Time
}

func (q *Queries) GetLedgerEntriesByWallet(ctx context.Context, walletID uuid.NullUUID) ([]GetLedgerEntriesByWalletRow, error) {
	rows, err := q.db.QueryContext(ctx, getLedgerEntriesByWallet, walletID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetLedgerEntriesByWalletRow
	for rows.Next() {
		var i GetLedgerEntriesByWalletRow
		if err := rows.Scan(
			&i.ID,
			&i.WalletID,
			&i.TransactionID,
			&i.AmountBigint,
			&i.BalanceAfter,
			&i.EntryType,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPaymentTransactionByProviderTx = `-- name: GetPaymentTransactionByProviderTx :one
SELECT id, topup_order_id, provider, provider_tx_id, amount_bigint, status, remote_payload, signature, verified_at, created_at
FROM payment_transaction
WHERE provider = $1 AND provider_tx_id = $2
LIMIT 1
`

type GetPaymentTransactionByProviderTxParams struct {
	Provider     string
	ProviderTxID string
}

type GetPaymentTransactionByProviderTxRow struct {
	ID            uuid.UUID
	TopupOrderID  uuid.NullUUID
	Provider      string
	ProviderTxID  string
	AmountBigint  int64
	Status        string
	RemotePayload pqtype.NullRawMessage
	Signature     sql.NullString
	VerifiedAt    sql.NullTime
	CreatedAt     time.Time
}

func (q *Queries) GetPaymentTransactionByProviderTx(ctx context.Context, arg GetPaymentTransactionByProviderTxParams) (GetPaymentTransactionByProviderTxRow, error) {
	row := q.db.QueryRowContext(ctx, getPaymentTransactionByProviderTx, arg.Provider, arg.ProviderTxID)
	var i GetPaymentTransactionByProviderTxRow
	err := row.Scan(
		&i.ID,
		&i.TopupOrderID,
		&i.Provider,
		&i.ProviderTxID,
		&i.AmountBigint,
		&i.Status,
		&i.RemotePayload,
		&i.Signature,
		&i.VerifiedAt,
		&i.CreatedAt,
	)
	return i, err
}

const getTopupByIdempotencyKeyAndOrder = `-- name: GetTopupByIdempotencyKeyAndOrder :one
SELECT id, user_id, order_id, reference_code, idempotency_key, amount_bigint, currency, provider, provider_payment_url, status, created_at, updated_at, expires_at
FROM topup_order
WHERE idempotency_key = $1
  AND order_id = $2
  AND status = 'PENDING'
LIMIT 1
`

type GetTopupByIdempotencyKeyAndOrderParams struct {
	IdempotencyKey string
	OrderID        uuid.NullUUID
}

func (q *Queries) GetTopupByIdempotencyKeyAndOrder(ctx context.Context, arg GetTopupByIdempotencyKeyAndOrderParams) (TopupOrder, error) {
	row := q.db.QueryRowContext(ctx, getTopupByIdempotencyKeyAndOrder, arg.IdempotencyKey, arg.OrderID)
	var i TopupOrder
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.OrderID,
		&i.ReferenceCode,
		&i.IdempotencyKey,
		&i.AmountBigint,
		&i.Currency,
		&i.Provider,
		&i.ProviderPaymentUrl,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ExpiresAt,
	)
	return i, err
}

const getTopupOrderByReference = `-- name: GetTopupOrderByReference :one
SELECT id, user_id, order_id, reference_code, idempotency_key, amount_bigint, currency, provider, provider_payment_url, status, created_at, updated_at, expires_at
FROM topup_order
WHERE reference_code = $1
LIMIT 1
`

func (q *Queries) GetTopupOrderByReference(ctx context.Context, referenceCode string) (TopupOrder, error) {
	row := q.db.QueryRowContext(ctx, getTopupOrderByReference, referenceCode)
	var i TopupOrder
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.OrderID,
		&i.ReferenceCode,
		&i.IdempotencyKey,
		&i.AmountBigint,
		&i.Currency,
		&i.Provider,
		&i.ProviderPaymentUrl,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ExpiresAt,
	)
	return i, err
}

const getWalletByUserID = `-- name: GetWalletByUserID :one
SELECT id, user_id, balance_bigint, updated_at, created_at
FROM wallet
WHERE user_id = $1
LIMIT 1
`

type GetWalletByUserIDRow struct {
	ID            uuid.UUID
	UserID        uuid.UUID
	BalanceBigint int64
	UpdatedAt     time.Time
	CreatedAt     time.Time
}

func (q *Queries) GetWalletByUserID(ctx context.Context, userID uuid.UUID) (GetWalletByUserIDRow, error) {
	row := q.db.QueryRowContext(ctx, getWalletByUserID, userID)
	var i GetWalletByUserIDRow
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.BalanceBigint,
		&i.UpdatedAt,
		&i.CreatedAt,
	)
	return i, err
}

const getWalletForUpdateByUser = `-- name: GetWalletForUpdateByUser :one
SELECT id, user_id, balance_bigint, updated_at, created_at
FROM wallet
WHERE user_id = $1
FOR UPDATE
`

type GetWalletForUpdateByUserRow struct {
	ID            uuid.UUID
	UserID        uuid.UUID
	BalanceBigint int64
	UpdatedAt     time.Time
	CreatedAt     time.Time
}

func (q *Queries) GetWalletForUpdateByUser(ctx context.Context, userID uuid.UUID) (GetWalletForUpdateByUserRow, error) {
	row := q.db.QueryRowContext(ctx, getWalletForUpdateByUser, userID)
	var i GetWalletForUpdateByUserRow
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.BalanceBigint,
		&i.UpdatedAt,
		&i.CreatedAt,
	)
	return i, err
}

const updateTopupOrderStatus = `-- name: UpdateTopupOrderStatus :one
UPDATE topup_order
SET status = $2,  updated_at = NOW()
WHERE id = $1
RETURNING id, status, updated_at,order_id
`

type UpdateTopupOrderStatusParams struct {
	ID     uuid.UUID
	Status string
}

type UpdateTopupOrderStatusRow struct {
	ID        uuid.UUID
	Status    string
	UpdatedAt time.Time
	OrderID   uuid.NullUUID
}

func (q *Queries) UpdateTopupOrderStatus(ctx context.Context, arg UpdateTopupOrderStatusParams) (UpdateTopupOrderStatusRow, error) {
	row := q.db.QueryRowContext(ctx, updateTopupOrderStatus, arg.ID, arg.Status)
	var i UpdateTopupOrderStatusRow
	err := row.Scan(
		&i.ID,
		&i.Status,
		&i.UpdatedAt,
		&i.OrderID,
	)
	return i, err
}

const updateTopupPaymentInfo = `-- name: UpdateTopupPaymentInfo :one
UPDATE topup_order
SET provider_payment_url = $2, expires_at = $3, updated_at = NOW()
WHERE id = $1
RETURNING id, provider_payment_url, expires_at, updated_at
`

type UpdateTopupPaymentInfoParams struct {
	ID                 uuid.UUID
	ProviderPaymentUrl sql.NullString
	ExpiresAt          sql.NullTime
}

type UpdateTopupPaymentInfoRow struct {
	ID                 uuid.UUID
	ProviderPaymentUrl sql.NullString
	ExpiresAt          sql.NullTime
	UpdatedAt          time.Time
}

func (q *Queries) UpdateTopupPaymentInfo(ctx context.Context, arg UpdateTopupPaymentInfoParams) (UpdateTopupPaymentInfoRow, error) {
	row := q.db.QueryRowContext(ctx, updateTopupPaymentInfo, arg.ID, arg.ProviderPaymentUrl, arg.ExpiresAt)
	var i UpdateTopupPaymentInfoRow
	err := row.Scan(
		&i.ID,
		&i.ProviderPaymentUrl,
		&i.ExpiresAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateWalletBalance = `-- name: UpdateWalletBalance :one
UPDATE wallet
SET balance_bigint = $2, updated_at = NOW()
WHERE id = $1
RETURNING id, user_id, balance_bigint, updated_at, created_at
`

type UpdateWalletBalanceParams struct {
	ID            uuid.UUID
	BalanceBigint int64
}

type UpdateWalletBalanceRow struct {
	ID            uuid.UUID
	UserID        uuid.UUID
	BalanceBigint int64
	UpdatedAt     time.Time
	CreatedAt     time.Time
}

func (q *Queries) UpdateWalletBalance(ctx context.Context, arg UpdateWalletBalanceParams) (UpdateWalletBalanceRow, error) {
	row := q.db.QueryRowContext(ctx, updateWalletBalance, arg.ID, arg.BalanceBigint)
	var i UpdateWalletBalanceRow
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.BalanceBigint,
		&i.UpdatedAt,
		&i.CreatedAt,
	)
	return i, err
}
