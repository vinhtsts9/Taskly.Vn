// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: gigs.sql

package database

import (
	"context"
	"database/sql"
	"encoding/json"
	"time"

	"github.com/google/uuid"
	"github.com/lib/pq"
	"github.com/sqlc-dev/pqtype"
)

const createGig = `-- name: CreateGig :one
INSERT INTO gigs (
  user_id, title,description, pricing_mode, category_id, image_url, status, updated_at
) VALUES (
  $1, $2, $3, $4, $5, $6, $7, NOW()
)
RETURNING id, user_id, title, category_id, image_url, description, pricing_mode, status, created_at, updated_at
`

type CreateGigParams struct {
	UserID      uuid.UUID
	Title       string
	Description string
	PricingMode string
	CategoryID  []int32
	ImageUrl    []string
	Status      string
}

func (q *Queries) CreateGig(ctx context.Context, arg CreateGigParams) (Gig, error) {
	row := q.db.QueryRowContext(ctx, createGig,
		arg.UserID,
		arg.Title,
		arg.Description,
		arg.PricingMode,
		pq.Array(arg.CategoryID),
		pq.Array(arg.ImageUrl),
		arg.Status,
	)
	var i Gig
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Title,
		pq.Array(&i.CategoryID),
		pq.Array(&i.ImageUrl),
		&i.Description,
		&i.PricingMode,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createGigPackage = `-- name: CreateGigPackage :one
INSERT INTO gig_packages (
      gig_id, tier, price, delivery_time, options
) VALUES (
      $1, $2, $3, $4, $5
)
RETURNING id, gig_id, tier, price, delivery_time, options, created_at, updated_at
`

type CreateGigPackageParams struct {
	GigID        uuid.UUID
	Tier         string
	Price        float64
	DeliveryTime int32
	Options      pqtype.NullRawMessage
}

func (q *Queries) CreateGigPackage(ctx context.Context, arg CreateGigPackageParams) (GigPackage, error) {
	row := q.db.QueryRowContext(ctx, createGigPackage,
		arg.GigID,
		arg.Tier,
		arg.Price,
		arg.DeliveryTime,
		arg.Options,
	)
	var i GigPackage
	err := row.Scan(
		&i.ID,
		&i.GigID,
		&i.Tier,
		&i.Price,
		&i.DeliveryTime,
		&i.Options,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createGigRequirement = `-- name: CreateGigRequirement :one
INSERT INTO gig_requirements (
      gig_id, question, required
) VALUES (
      $1, $2, $3
    )
    RETURNING id, gig_id, question, required, created_at, updated_at
`

type CreateGigRequirementParams struct {
	GigID    uuid.UUID
	Question string
	Required bool
}

func (q *Queries) CreateGigRequirement(ctx context.Context, arg CreateGigRequirementParams) (GigRequirement, error) {
	row := q.db.QueryRowContext(ctx, createGigRequirement, arg.GigID, arg.Question, arg.Required)
	var i GigRequirement
	err := row.Scan(
		&i.ID,
		&i.GigID,
		&i.Question,
		&i.Required,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteService = `-- name: DeleteService :exec
DELETE FROM gigs WHERE id = $1
`

func (q *Queries) DeleteService(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, deleteService, id)
	return err
}

const getCategories = `-- name: GetCategories :many
select 
c1.id as parent_id,
c1.name as parent_name,
c2.id as children_id,
c2.name as children_name
from categories c1
left join categories c2 on c1.id = c2.parent_id
`

type GetCategoriesRow struct {
	ParentID     int32
	ParentName   string
	ChildrenID   sql.NullInt32
	ChildrenName sql.NullString
}

func (q *Queries) GetCategories(ctx context.Context) ([]GetCategoriesRow, error) {
	rows, err := q.db.QueryContext(ctx, getCategories)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetCategoriesRow
	for rows.Next() {
		var i GetCategoriesRow
		if err := rows.Scan(
			&i.ParentID,
			&i.ParentName,
			&i.ChildrenID,
			&i.ChildrenName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getGigAndPackagesForOrder = `-- name: GetGigAndPackagesForOrder :one
SELECT
    g.id,
    g.user_id,
    json_agg(
        json_build_object(
            'tier', gp.tier,
            'price', gp.price
        )
    ) FILTER (WHERE gp.id IS NOT NULL) AS gig_packages
FROM gigs g
LEFT JOIN gig_packages gp ON g.id = gp.gig_id
WHERE g.id = $1
GROUP BY g.id
`

type GetGigAndPackagesForOrderRow struct {
	ID          uuid.UUID
	UserID      uuid.UUID
	GigPackages json.RawMessage
}

func (q *Queries) GetGigAndPackagesForOrder(ctx context.Context, id uuid.UUID) (GetGigAndPackagesForOrderRow, error) {
	row := q.db.QueryRowContext(ctx, getGigAndPackagesForOrder, id)
	var i GetGigAndPackagesForOrderRow
	err := row.Scan(&i.ID, &i.UserID, &i.GigPackages)
	return i, err
}

const getGigPackagesByGigID = `-- name: GetGigPackagesByGigID :many
SELECT
        id,
        gig_id,
        tier,
        price,
        delivery_time,
        options
FROM
        gig_packages
WHERE
        gig_id = $1
`

type GetGigPackagesByGigIDRow struct {
	ID           uuid.UUID
	GigID        uuid.UUID
	Tier         string
	Price        float64
	DeliveryTime int32
	Options      pqtype.NullRawMessage
}

func (q *Queries) GetGigPackagesByGigID(ctx context.Context, gigID uuid.UUID) ([]GetGigPackagesByGigIDRow, error) {
	rows, err := q.db.QueryContext(ctx, getGigPackagesByGigID, gigID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetGigPackagesByGigIDRow
	for rows.Next() {
		var i GetGigPackagesByGigIDRow
		if err := rows.Scan(
			&i.ID,
			&i.GigID,
			&i.Tier,
			&i.Price,
			&i.DeliveryTime,
			&i.Options,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getGigRequirementsByGigID = `-- name: GetGigRequirementsByGigID :many
SELECT
        id,
        gig_id,
        question,
        required
FROM
        gig_requirements
WHERE
        gig_id = $1
`

type GetGigRequirementsByGigIDRow struct {
	ID       uuid.UUID
	GigID    uuid.UUID
	Question string
	Required bool
}

func (q *Queries) GetGigRequirementsByGigID(ctx context.Context, gigID uuid.UUID) ([]GetGigRequirementsByGigIDRow, error) {
	rows, err := q.db.QueryContext(ctx, getGigRequirementsByGigID, gigID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetGigRequirementsByGigIDRow
	for rows.Next() {
		var i GetGigRequirementsByGigIDRow
		if err := rows.Scan(
			&i.ID,
			&i.GigID,
			&i.Question,
			&i.Required,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getService = `-- name: GetService :one
SELECT
    g.id,
    g.user_id,
    g.title,
    g.description,
    g.category_id,
    g.image_url,
    g.pricing_mode,
    g.status,
    g.created_at,
    g.updated_at,
    array_remove(array_agg(c.name), NULL)::text[] AS category_name,
    u.names AS user_name,
    u.profile_pic AS user_profile_pic
FROM gigs g
JOIN users u ON g.user_id = u.id
JOIN categories c ON c.id = ANY(g.category_id)
WHERE g.id = $1
GROUP BY g.id, g.user_id, g.title, g.description, g.category_id,
         g.image_url, g.pricing_mode, g.status, g.created_at,
         g.updated_at, u.names, u.profile_pic
`

type GetServiceRow struct {
	ID             uuid.UUID
	UserID         uuid.UUID
	Title          string
	Description    string
	CategoryID     []int32
	ImageUrl       []string
	PricingMode    string
	Status         string
	CreatedAt      time.Time
	UpdatedAt      time.Time
	CategoryName   []string
	UserName       string
	UserProfilePic sql.NullString
}

func (q *Queries) GetService(ctx context.Context, id uuid.UUID) (GetServiceRow, error) {
	row := q.db.QueryRowContext(ctx, getService, id)
	var i GetServiceRow
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Title,
		&i.Description,
		pq.Array(&i.CategoryID),
		pq.Array(&i.ImageUrl),
		&i.PricingMode,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
		pq.Array(&i.CategoryName),
		&i.UserName,
		&i.UserProfilePic,
	)
	return i, err
}

const searchGigs = `-- name: SearchGigs :many
SELECT
    g.id,
    g.title,
    g.description,
    g.image_url,
    g.pricing_mode,
    g.created_at,
    g.updated_at,
    COALESCE(bp.price, 0) AS basic_price
FROM gigs g
LEFT JOIN gig_packages bp 
    ON bp.gig_id = g.id 
    AND bp.tier = 'basic'
WHERE
    (
        LOWER(g.title) LIKE LOWER('%' || $1::text || '%') OR
        LOWER(g.description) LIKE LOWER('%' || $1::text || '%') OR
        $1::text IS NULL
    )
    AND (
        ($2::float8 = 0 AND $3::float8 = 0) OR -- Thêm điều kiện này
        (bp.price >= $2::float8 OR $2::float8 IS NULL)
    )
    AND (
        ($3::float8 = 0 AND $2::float8 = 0) OR -- Thêm điều kiện này
        (bp.price <= $3::float8 OR $3::float8 IS NULL)
    )
    AND (
        array_length($4::int[], 1) IS NULL OR $4::int[] IS NULL OR g.category_id && $4::int[]
    )
    AND (
        $5::uuid = '00000000-0000-0000-0000-000000000000' OR $5::uuid IS NULL OR g.id < $5::uuid
    )
ORDER BY g.id DESC
LIMIT 10
`

type SearchGigsParams struct {
	SearchTerm  string
	MinPrice    float64
	MaxPrice    float64
	CategoryIds []int32
	LastGigID   uuid.UUID
}

type SearchGigsRow struct {
	ID          uuid.UUID
	Title       string
	Description string
	ImageUrl    []string
	PricingMode string
	CreatedAt   time.Time
	UpdatedAt   time.Time
	BasicPrice  float64
}

func (q *Queries) SearchGigs(ctx context.Context, arg SearchGigsParams) ([]SearchGigsRow, error) {
	rows, err := q.db.QueryContext(ctx, searchGigs,
		arg.SearchTerm,
		arg.MinPrice,
		arg.MaxPrice,
		pq.Array(arg.CategoryIds),
		arg.LastGigID,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SearchGigsRow
	for rows.Next() {
		var i SearchGigsRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Description,
			pq.Array(&i.ImageUrl),
			&i.PricingMode,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.BasicPrice,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateService = `-- name: UpdateService :one
UPDATE gigs
SET
    title = $2,
    description = $3,
    category_id = $4,
    image_url = $5,
    pricing_mode = $6,
    status = $7,
    updated_at = NOW()
WHERE id = $1
RETURNING id, user_id, title, category_id, image_url, description, pricing_mode, status, created_at, updated_at
`

type UpdateServiceParams struct {
	ID          uuid.UUID
	Title       string
	Description string
	CategoryID  []int32
	ImageUrl    []string
	PricingMode string
	Status      string
}

func (q *Queries) UpdateService(ctx context.Context, arg UpdateServiceParams) (Gig, error) {
	row := q.db.QueryRowContext(ctx, updateService,
		arg.ID,
		arg.Title,
		arg.Description,
		pq.Array(arg.CategoryID),
		pq.Array(arg.ImageUrl),
		arg.PricingMode,
		arg.Status,
	)
	var i Gig
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Title,
		pq.Array(&i.CategoryID),
		pq.Array(&i.ImageUrl),
		&i.Description,
		&i.PricingMode,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
